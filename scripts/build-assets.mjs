import fs from 'node:fs/promises';
import path from 'node:path';
import sharp from 'sharp';

const cwd = process.cwd();
const generatedDir = path.join(cwd, 'generated');

const GALLERY_INPUT = path.join(cwd, 'public', 'gallery-src');
const GALLERY_OUTPUT = path.join(cwd, 'public', 'gallery');
const GALLERY_MANIFEST = path.join(generatedDir, 'galleryManifest.ts');

const PROJECTS_ROOT = path.join(cwd, 'public', 'projects');
const COLLAGE_SRC_NAME = 'collage-src';
const COLLAGE_OUTPUT_NAME = 'collage';
const COLLAGE_MANIFEST = path.join(generatedDir, 'projectCollageManifest.ts');
const APPROACH_SRC_NAME = 'approach-src';
const APPROACH_OUTPUT_NAME = 'approach';
const APPROACH_MANIFEST = path.join(generatedDir, 'approachManifest.ts');
const PROTOTYPE_SRC_NAME = 'prototypes-src';
const PROTOTYPE_OUTPUT_NAME = 'prototypes';
const PROTOTYPE_MANIFEST = path.join(generatedDir, 'prototypeManifest.ts');

const GALLERY_MAX_WIDTH = Number(process.env.GALLERY_MAX_WIDTH ?? 2000);
const GALLERY_WEBP_QUALITY = Number(process.env.GALLERY_WEBP_QUALITY ?? 80);
const GALLERY_AVIF_QUALITY = Number(process.env.GALLERY_AVIF_QUALITY ?? 50);
const GALLERY_ENABLE_AVIF = process.env.GALLERY_AVIF !== '0';

const COLLAGE_MAX_HEIGHT = Number(process.env.COLLAGE_MAX_HEIGHT ?? 300);
const COLLAGE_WEBP_QUALITY = Number(process.env.COLLAGE_WEBP_QUALITY ?? 92);
const APPROACH_MAX_WIDTH = Number(process.env.APPROACH_MAX_WIDTH ?? 1600);
const APPROACH_WEBP_QUALITY = Number(process.env.APPROACH_WEBP_QUALITY ?? 90);
const PROTOTYPE_MAX_WIDTH = Number(process.env.PROTOTYPE_MAX_WIDTH ?? 1200);
const PROTOTYPE_WEBP_QUALITY = Number(process.env.PROTOTYPE_WEBP_QUALITY ?? 90);

const GALLERY_EXTS = new Set(['.png', '.jpg', '.jpeg', '.tif', '.tiff']);
const COLLAGE_EXTS = new Set(['.png', '.jpg', '.jpeg', '.tif', '.tiff', '.gif', '.webp']);
const COLLAGE_EXT_PRIORITY = ['.gif', '.webp', '.png', '.jpg', '.jpeg', '.tif', '.tiff'];
const IMAGE_EXTS = ['.png', '.jpg', '.jpeg', '.tif', '.tiff', '.webp'];
const VIDEO_EXTS = ['.mp4', '.webm', '.mov'];
const APPROACH_EXTS = new Set([...IMAGE_EXTS, '.gif', ...VIDEO_EXTS]);
const PROTOTYPE_EXTS = new Set([...IMAGE_EXTS, '.gif']);
const APPROACH_EXT_PRIORITY = [...VIDEO_EXTS, '.jpg', '.jpeg', '.png', '.webp', '.gif', '.tif', '.tiff'];
const PROTOTYPE_EXT_PRIORITY = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.tif', '.tiff'];

const ensureDir = async (dir) => {
  await fs.mkdir(dir, { recursive: true });
};

const listFiles = async (dir) => {
  try {
    return await fs.readdir(dir);
  } catch (error) {
    if (error.code === 'ENOENT') return [];
    throw error;
  }
};

const cleanOutput = async (dir, exts) => {
  try {
    const files = await fs.readdir(dir);
    await Promise.all(
      files
        .filter((file) => exts.has(path.extname(file).toLowerCase()))
        .map((file) => fs.unlink(path.join(dir, file)))
    );
  } catch (error) {
    if (error.code !== 'ENOENT') throw error;
  }
};

const computeTargetSize = (width, height, { maxWidth, maxHeight, minHeight }) => {
  const widthScale = maxWidth ? maxWidth / width : 1;
  const heightScale = maxHeight ? maxHeight / height : 1;
  const scale = Math.min(1, widthScale, heightScale);
  let nextWidth = Math.max(1, Math.round(width * scale));
  let nextHeight = Math.max(1, Math.round(height * scale));

  if (minHeight && nextHeight < minHeight) {
    const upscale = minHeight / nextHeight;
    nextWidth = Math.max(1, Math.round(nextWidth * upscale));
    nextHeight = Math.max(1, Math.round(nextHeight * upscale));
  }

  return { width: nextWidth, height: nextHeight };
};

const readGifDimensions = async (filePath) => {
  const buffer = await fs.readFile(filePath);
  if (buffer.length < 10) {
    throw new Error(`Invalid GIF file: ${filePath}`);
  }

  const signature = buffer.toString('ascii', 0, 6);
  if (signature !== 'GIF87a' && signature !== 'GIF89a') {
    throw new Error(`Invalid GIF signature for ${filePath}`);
  }

  return {
    width: buffer.readUInt16LE(6),
    height: buffer.readUInt16LE(8)
  };
};

const writeGalleryManifest = async (manifest) => {
  const contents = `// Auto-generated by scripts/build-assets.mjs. Do not edit by hand.\n\nexport type GalleryManifestItem = {\n  id: string;\n  width: number;\n  height: number;\n  srcWebp: string;\n  srcAvif: string;\n};\n\nexport const GALLERY_MANIFEST: GalleryManifestItem[] = ${JSON.stringify(
    manifest,
    null,
    2
  )};\n`;

  await ensureDir(generatedDir);
  await fs.writeFile(GALLERY_MANIFEST, contents, 'utf8');
};

const writeCollageManifest = async (manifest) => {
  const contents = `// Auto-generated by scripts/build-assets.mjs. Do not edit by hand.\n\nexport type ProjectCollageItem = {\n  id: string;\n  width: number;\n  height: number;\n  src: string;\n};\n\nexport const PROJECT_COLLAGE_MANIFEST: Record<string, ProjectCollageItem[]> = ${JSON.stringify(
    manifest,
    null,
    2
  )};\n`;

  await ensureDir(generatedDir);
  await fs.writeFile(COLLAGE_MANIFEST, contents, 'utf8');
};

const writeApproachManifest = async (manifest) => {
  const contents = `// Auto-generated by scripts/build-assets.mjs. Do not edit by hand.\n\nexport type ApproachMediaItem = {\n  id: string;\n  type: 'image' | 'video';\n  src: string;\n};\n\nexport const APPROACH_MANIFEST: Record<string, ApproachMediaItem[]> = ${JSON.stringify(
    manifest,
    null,
    2
  )};\n`;

  await ensureDir(generatedDir);
  await fs.writeFile(APPROACH_MANIFEST, contents, 'utf8');
};

const writePrototypeManifest = async (manifest) => {
  const contents = `// Auto-generated by scripts/build-assets.mjs. Do not edit by hand.\n\nexport type PrototypeMediaItem = {\n  id: string;\n  src: string;\n};\n\nexport const PROTOTYPE_MANIFEST: Record<string, PrototypeMediaItem[]> = ${JSON.stringify(
    manifest,
    null,
    2
  )};\n`;

  await ensureDir(generatedDir);
  await fs.writeFile(PROTOTYPE_MANIFEST, contents, 'utf8');
};

const processGallery = async () => {
  await ensureDir(GALLERY_INPUT);
  await ensureDir(GALLERY_OUTPUT);

  const files = (await listFiles(GALLERY_INPUT)).filter((file) =>
    GALLERY_EXTS.has(path.extname(file).toLowerCase())
  );

  if (files.length === 0) {
    console.log('No gallery source images found in public/gallery-src.');
    return;
  }

  await cleanOutput(GALLERY_OUTPUT, new Set(['.webp', '.avif']));

  const entries = [];

  for (const file of files) {
    const sourcePath = path.join(GALLERY_INPUT, file);
    const id = path.parse(file).name;

    const metadata = await sharp(sourcePath).metadata();
    if (!metadata.width || !metadata.height) {
      throw new Error(`Failed to read dimensions for ${file}`);
    }

    const target = computeTargetSize(metadata.width, metadata.height, { maxWidth: GALLERY_MAX_WIDTH });

    const resized = sharp(sourcePath)
      .rotate()
      .resize({ width: GALLERY_MAX_WIDTH, withoutEnlargement: true });

    const webpPath = path.join(GALLERY_OUTPUT, `${id}.webp`);
    const avifPath = path.join(GALLERY_OUTPUT, `${id}.avif`);

    await resized.clone().webp({ quality: GALLERY_WEBP_QUALITY }).toFile(webpPath);
    if (GALLERY_ENABLE_AVIF) {
      await resized.clone().avif({ quality: GALLERY_AVIF_QUALITY }).toFile(avifPath);
    }

    entries.push({
      id,
      width: target.width,
      height: target.height,
      srcWebp: `/gallery/${id}.webp`,
      srcAvif: GALLERY_ENABLE_AVIF ? `/gallery/${id}.avif` : ''
    });

    console.log(`Optimized gallery ${file} -> ${id}.webp${GALLERY_ENABLE_AVIF ? ' + .avif' : ''}`);
  }

  entries.sort((a, b) => a.id.localeCompare(b.id, 'en', { numeric: true }));
  await writeGalleryManifest(entries);
  console.log(`Wrote gallery manifest: ${path.relative(cwd, GALLERY_MANIFEST)}`);
};

const pickPreferredFiles = (files, priority) => {
  const grouped = new Map();
  for (const file of files) {
    const ext = path.extname(file).toLowerCase();
    const id = path.parse(file).name;
    if (!grouped.has(id)) grouped.set(id, []);
    grouped.get(id).push({ file, ext });
  }

  const selected = [];
  for (const [id, variants] of grouped.entries()) {
    const chosen = priority.map((ext) => variants.find((item) => item.ext === ext)).find(Boolean);
    if (chosen) {
      selected.push({ id, file: chosen.file, ext: chosen.ext });
    }
  }

  selected.sort((a, b) => a.id.localeCompare(b.id, 'en', { numeric: true }));
  return selected;
};

const processProjectCollages = async () => {
  const projectDirs = await listFiles(PROJECTS_ROOT);
  const manifest = {};

  for (const projectId of projectDirs) {
    const projectPath = path.join(PROJECTS_ROOT, projectId);
    const collageSrc = path.join(projectPath, COLLAGE_SRC_NAME);
    const collageOut = path.join(projectPath, COLLAGE_OUTPUT_NAME);

    const entries = (await listFiles(collageSrc)).filter((file) =>
      COLLAGE_EXTS.has(path.extname(file).toLowerCase())
    );

    if (entries.length === 0) {
      continue;
    }

    await ensureDir(collageOut);
    await cleanOutput(collageOut, new Set(['.webp', '.avif', '.gif', '.jpg', '.jpeg', '.png', '.tif', '.tiff']));

    const selected = pickPreferredFiles(entries, COLLAGE_EXT_PRIORITY);
    const items = [];

    for (const entry of selected) {
      const sourcePath = path.join(collageSrc, entry.file);
      const isGif = entry.ext === '.gif';
      const metadata = isGif
        ? await readGifDimensions(sourcePath)
        : await sharp(sourcePath).metadata();

      if (!metadata.width || !metadata.height) {
        throw new Error(`Failed to read dimensions for ${entry.file}`);
      }

      const target = isGif
        ? computeTargetSize(metadata.width, metadata.height, {
            maxHeight: COLLAGE_MAX_HEIGHT,
            minHeight: COLLAGE_MAX_HEIGHT
          })
        : computeTargetSize(metadata.width, metadata.height, { maxHeight: COLLAGE_MAX_HEIGHT });

      if (isGif) {
        const destPath = path.join(collageOut, `${entry.id}.gif`);
        await fs.copyFile(sourcePath, destPath);
        items.push({
          id: entry.id,
          width: target.width,
          height: target.height,
          src: `/projects/${projectId}/collage/${entry.id}.gif`
        });
        console.log(`Copied collage GIF ${projectId}/${entry.file}`);
      } else {
        const outputPath = path.join(collageOut, `${entry.id}.webp`);
        await sharp(sourcePath)
          .rotate()
          .resize({ height: COLLAGE_MAX_HEIGHT, withoutEnlargement: true })
          .webp({ quality: COLLAGE_WEBP_QUALITY })
          .toFile(outputPath);
        items.push({
          id: entry.id,
          width: target.width,
          height: target.height,
          src: `/projects/${projectId}/collage/${entry.id}.webp`
        });
        console.log(`Optimized collage ${projectId}/${entry.file} -> ${entry.id}.webp`);
      }
    }

    manifest[projectId] = items;
  }

  await writeCollageManifest(manifest);
  console.log(`Wrote collage manifest: ${path.relative(cwd, COLLAGE_MANIFEST)}`);
};

const processProjectApproach = async () => {
  const projectDirs = await listFiles(PROJECTS_ROOT);
  const manifest = {};
  const outputExts = new Set(['.webp', '.gif', '.jpg', '.jpeg', '.png', '.tif', '.tiff', '.mp4', '.webm', '.mov']);

  for (const projectId of projectDirs) {
    const projectPath = path.join(PROJECTS_ROOT, projectId);
    const approachSrc = path.join(projectPath, APPROACH_SRC_NAME);
    const approachOut = path.join(projectPath, APPROACH_OUTPUT_NAME);

    const entries = (await listFiles(approachSrc)).filter((file) =>
      APPROACH_EXTS.has(path.extname(file).toLowerCase())
    );

    if (entries.length === 0) {
      continue;
    }

    await ensureDir(approachOut);
    await cleanOutput(approachOut, outputExts);

    const selected = pickPreferredFiles(entries, APPROACH_EXT_PRIORITY);
    const items = [];

    for (const entry of selected) {
      const sourcePath = path.join(approachSrc, entry.file);
      const ext = entry.ext;

      if (VIDEO_EXTS.includes(ext)) {
        const destPath = path.join(approachOut, `${entry.id}${ext}`);
        await fs.copyFile(sourcePath, destPath);
        items.push({
          id: entry.id,
          type: 'video',
          src: `/projects/${projectId}/approach/${entry.id}${ext}`
        });
        console.log(`Copied approach video ${projectId}/${entry.file}`);
        continue;
      }

      if (ext === '.gif') {
        const destPath = path.join(approachOut, `${entry.id}.gif`);
        await fs.copyFile(sourcePath, destPath);
        items.push({
          id: entry.id,
          type: 'image',
          src: `/projects/${projectId}/approach/${entry.id}.gif`
        });
        console.log(`Copied approach GIF ${projectId}/${entry.file}`);
        continue;
      }

      const outputPath = path.join(approachOut, `${entry.id}.webp`);
      await sharp(sourcePath)
        .rotate()
        .resize({ width: APPROACH_MAX_WIDTH, withoutEnlargement: true })
        .webp({ quality: APPROACH_WEBP_QUALITY })
        .toFile(outputPath);
      items.push({
        id: entry.id,
        type: 'image',
        src: `/projects/${projectId}/approach/${entry.id}.webp`
      });
      console.log(`Optimized approach ${projectId}/${entry.file} -> ${entry.id}.webp`);
    }

    manifest[projectId] = items;
  }

  await writeApproachManifest(manifest);
  console.log(`Wrote approach manifest: ${path.relative(cwd, APPROACH_MANIFEST)}`);
};

const processProjectPrototypes = async () => {
  const projectDirs = await listFiles(PROJECTS_ROOT);
  const manifest = {};
  const outputExts = new Set(['.webp', '.gif', '.jpg', '.jpeg', '.png', '.tif', '.tiff']);

  for (const projectId of projectDirs) {
    const projectPath = path.join(PROJECTS_ROOT, projectId);
    const prototypeSrc = path.join(projectPath, PROTOTYPE_SRC_NAME);
    const prototypeOut = path.join(projectPath, PROTOTYPE_OUTPUT_NAME);

    const entries = (await listFiles(prototypeSrc)).filter((file) =>
      PROTOTYPE_EXTS.has(path.extname(file).toLowerCase())
    );

    if (entries.length === 0) {
      continue;
    }

    await ensureDir(prototypeOut);
    await cleanOutput(prototypeOut, outputExts);

    const selected = pickPreferredFiles(entries, PROTOTYPE_EXT_PRIORITY);
    const items = [];

    for (const entry of selected) {
      const sourcePath = path.join(prototypeSrc, entry.file);
      const ext = entry.ext;

      if (ext === '.gif') {
        const destPath = path.join(prototypeOut, `${entry.id}.gif`);
        await fs.copyFile(sourcePath, destPath);
        items.push({
          id: entry.id,
          src: `/projects/${projectId}/prototypes/${entry.id}.gif`
        });
        console.log(`Copied prototype GIF ${projectId}/${entry.file}`);
        continue;
      }

      const outputPath = path.join(prototypeOut, `${entry.id}.webp`);
      await sharp(sourcePath)
        .rotate()
        .resize({ width: PROTOTYPE_MAX_WIDTH, withoutEnlargement: true })
        .webp({ quality: PROTOTYPE_WEBP_QUALITY })
        .toFile(outputPath);
      items.push({
        id: entry.id,
        src: `/projects/${projectId}/prototypes/${entry.id}.webp`
      });
      console.log(`Optimized prototype ${projectId}/${entry.file} -> ${entry.id}.webp`);
    }

    manifest[projectId] = items;
  }

  await writePrototypeManifest(manifest);
  console.log(`Wrote prototype manifest: ${path.relative(cwd, PROTOTYPE_MANIFEST)}`);
};

const main = async () => {
  await processGallery();
  await processProjectCollages();
  await processProjectApproach();
  await processProjectPrototypes();
};

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
