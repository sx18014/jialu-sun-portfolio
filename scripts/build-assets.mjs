import fs from 'node:fs/promises';
import path from 'node:path';
import sharp from 'sharp';

const cwd = process.cwd();
const generatedDir = path.join(cwd, 'generated');

const GALLERY_INPUT = path.join(cwd, 'public', 'gallery-src');
const GALLERY_OUTPUT = path.join(cwd, 'public', 'gallery');
const GALLERY_MANIFEST = path.join(generatedDir, 'galleryManifest.ts');

const PROJECTS_ROOT = path.join(cwd, 'public', 'projects');
const COLLAGE_SRC_NAME = 'collage-src';
const COLLAGE_OUTPUT_NAME = 'collage';
const COLLAGE_MANIFEST = path.join(generatedDir, 'projectCollageManifest.ts');

const GALLERY_MAX_WIDTH = Number(process.env.GALLERY_MAX_WIDTH ?? 2000);
const GALLERY_WEBP_QUALITY = Number(process.env.GALLERY_WEBP_QUALITY ?? 80);
const GALLERY_AVIF_QUALITY = Number(process.env.GALLERY_AVIF_QUALITY ?? 50);
const GALLERY_ENABLE_AVIF = process.env.GALLERY_AVIF !== '0';

const COLLAGE_MAX_HEIGHT = Number(process.env.COLLAGE_MAX_HEIGHT ?? 250);
const COLLAGE_WEBP_QUALITY = Number(process.env.COLLAGE_WEBP_QUALITY ?? 80);

const GALLERY_EXTS = new Set(['.png', '.jpg', '.jpeg', '.tif', '.tiff']);
const COLLAGE_EXTS = new Set(['.png', '.jpg', '.jpeg', '.tif', '.tiff', '.gif', '.webp']);
const COLLAGE_EXT_PRIORITY = ['.gif', '.webp', '.png', '.jpg', '.jpeg', '.tif', '.tiff'];

const ensureDir = async (dir) => {
  await fs.mkdir(dir, { recursive: true });
};

const listFiles = async (dir) => {
  try {
    return await fs.readdir(dir);
  } catch (error) {
    if (error.code === 'ENOENT') return [];
    throw error;
  }
};

const cleanOutput = async (dir, exts) => {
  try {
    const files = await fs.readdir(dir);
    await Promise.all(
      files
        .filter((file) => exts.has(path.extname(file).toLowerCase()))
        .map((file) => fs.unlink(path.join(dir, file)))
    );
  } catch (error) {
    if (error.code !== 'ENOENT') throw error;
  }
};

const computeTargetSize = (width, height, { maxWidth, maxHeight }) => {
  const widthScale = maxWidth ? maxWidth / width : 1;
  const heightScale = maxHeight ? maxHeight / height : 1;
  const scale = Math.min(1, widthScale, heightScale);
  return {
    width: Math.max(1, Math.round(width * scale)),
    height: Math.max(1, Math.round(height * scale))
  };
};

const writeGalleryManifest = async (manifest) => {
  const contents = `// Auto-generated by scripts/build-assets.mjs. Do not edit by hand.\n\nexport type GalleryManifestItem = {\n  id: string;\n  width: number;\n  height: number;\n  srcWebp: string;\n  srcAvif: string;\n};\n\nexport const GALLERY_MANIFEST: GalleryManifestItem[] = ${JSON.stringify(
    manifest,
    null,
    2
  )};\n`;

  await ensureDir(generatedDir);
  await fs.writeFile(GALLERY_MANIFEST, contents, 'utf8');
};

const writeCollageManifest = async (manifest) => {
  const contents = `// Auto-generated by scripts/build-assets.mjs. Do not edit by hand.\n\nexport type ProjectCollageItem = {\n  id: string;\n  width: number;\n  height: number;\n  src: string;\n};\n\nexport const PROJECT_COLLAGE_MANIFEST: Record<string, ProjectCollageItem[]> = ${JSON.stringify(
    manifest,
    null,
    2
  )};\n`;

  await ensureDir(generatedDir);
  await fs.writeFile(COLLAGE_MANIFEST, contents, 'utf8');
};

const processGallery = async () => {
  await ensureDir(GALLERY_INPUT);
  await ensureDir(GALLERY_OUTPUT);

  const files = (await listFiles(GALLERY_INPUT)).filter((file) =>
    GALLERY_EXTS.has(path.extname(file).toLowerCase())
  );

  if (files.length === 0) {
    console.log('No gallery source images found in public/gallery-src.');
    return;
  }

  await cleanOutput(GALLERY_OUTPUT, new Set(['.webp', '.avif']));

  const entries = [];

  for (const file of files) {
    const sourcePath = path.join(GALLERY_INPUT, file);
    const id = path.parse(file).name;

    const metadata = await sharp(sourcePath).metadata();
    if (!metadata.width || !metadata.height) {
      throw new Error(`Failed to read dimensions for ${file}`);
    }

    const target = computeTargetSize(metadata.width, metadata.height, { maxWidth: GALLERY_MAX_WIDTH });

    const resized = sharp(sourcePath)
      .rotate()
      .resize({ width: GALLERY_MAX_WIDTH, withoutEnlargement: true });

    const webpPath = path.join(GALLERY_OUTPUT, `${id}.webp`);
    const avifPath = path.join(GALLERY_OUTPUT, `${id}.avif`);

    await resized.clone().webp({ quality: GALLERY_WEBP_QUALITY }).toFile(webpPath);
    if (GALLERY_ENABLE_AVIF) {
      await resized.clone().avif({ quality: GALLERY_AVIF_QUALITY }).toFile(avifPath);
    }

    entries.push({
      id,
      width: target.width,
      height: target.height,
      srcWebp: `/gallery/${id}.webp`,
      srcAvif: GALLERY_ENABLE_AVIF ? `/gallery/${id}.avif` : ''
    });

    console.log(`Optimized gallery ${file} -> ${id}.webp${GALLERY_ENABLE_AVIF ? ' + .avif' : ''}`);
  }

  entries.sort((a, b) => a.id.localeCompare(b.id, 'en', { numeric: true }));
  await writeGalleryManifest(entries);
  console.log(`Wrote gallery manifest: ${path.relative(cwd, GALLERY_MANIFEST)}`);
};

const pickPreferredFiles = (files) => {
  const grouped = new Map();
  for (const file of files) {
    const ext = path.extname(file).toLowerCase();
    const id = path.parse(file).name;
    if (!grouped.has(id)) grouped.set(id, []);
    grouped.get(id).push({ file, ext });
  }

  const selected = [];
  for (const [id, variants] of grouped.entries()) {
    const chosen = COLLAGE_EXT_PRIORITY.map((ext) => variants.find((item) => item.ext === ext)).find(Boolean);
    if (chosen) {
      selected.push({ id, file: chosen.file, ext: chosen.ext });
    }
  }

  selected.sort((a, b) => a.id.localeCompare(b.id, 'en', { numeric: true }));
  return selected;
};

const processProjectCollages = async () => {
  const projectDirs = await listFiles(PROJECTS_ROOT);
  const manifest = {};

  for (const projectId of projectDirs) {
    const projectPath = path.join(PROJECTS_ROOT, projectId);
    const collageSrc = path.join(projectPath, COLLAGE_SRC_NAME);
    const collageOut = path.join(projectPath, COLLAGE_OUTPUT_NAME);

    const entries = (await listFiles(collageSrc)).filter((file) =>
      COLLAGE_EXTS.has(path.extname(file).toLowerCase())
    );

    if (entries.length === 0) {
      continue;
    }

    await ensureDir(collageOut);
    await cleanOutput(collageOut, new Set(['.webp', '.avif', '.gif', '.jpg', '.jpeg', '.png', '.tif', '.tiff']));

    const selected = pickPreferredFiles(entries);
    const items = [];

    for (const entry of selected) {
      const sourcePath = path.join(collageSrc, entry.file);
      const metadata = await sharp(sourcePath, { animated: true }).metadata();
      if (!metadata.width || !metadata.height) {
        throw new Error(`Failed to read dimensions for ${entry.file}`);
      }

      const target = computeTargetSize(metadata.width, metadata.height, { maxHeight: COLLAGE_MAX_HEIGHT });

      if (entry.ext === '.gif') {
        const destPath = path.join(collageOut, `${entry.id}.gif`);
        await fs.copyFile(sourcePath, destPath);
        items.push({
          id: entry.id,
          width: target.width,
          height: target.height,
          src: `/projects/${projectId}/collage/${entry.id}.gif`
        });
        console.log(`Copied collage GIF ${projectId}/${entry.file}`);
      } else {
        const outputPath = path.join(collageOut, `${entry.id}.webp`);
        await sharp(sourcePath)
          .rotate()
          .resize({ height: COLLAGE_MAX_HEIGHT, withoutEnlargement: true })
          .webp({ quality: COLLAGE_WEBP_QUALITY })
          .toFile(outputPath);
        items.push({
          id: entry.id,
          width: target.width,
          height: target.height,
          src: `/projects/${projectId}/collage/${entry.id}.webp`
        });
        console.log(`Optimized collage ${projectId}/${entry.file} -> ${entry.id}.webp`);
      }
    }

    manifest[projectId] = items;
  }

  await writeCollageManifest(manifest);
  console.log(`Wrote collage manifest: ${path.relative(cwd, COLLAGE_MANIFEST)}`);
};

const main = async () => {
  await processGallery();
  await processProjectCollages();
};

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
