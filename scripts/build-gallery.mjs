import fs from 'node:fs/promises';
import path from 'node:path';
import sharp from 'sharp';

const cwd = process.cwd();
const inputDir = path.join(cwd, 'public', 'gallery-src');
const outputDir = path.join(cwd, 'public', 'gallery');
const manifestDir = path.join(cwd, 'generated');
const manifestPath = path.join(manifestDir, 'galleryManifest.ts');

const MAX_WIDTH = Number(process.env.GALLERY_MAX_WIDTH ?? 2000);
const WEBP_QUALITY = Number(process.env.GALLERY_WEBP_QUALITY ?? 80);
const AVIF_QUALITY = Number(process.env.GALLERY_AVIF_QUALITY ?? 50);
const ENABLE_AVIF = process.env.GALLERY_AVIF !== '0';

const exts = new Set(['.png', '.jpg', '.jpeg', '.tif', '.tiff']);

const ensureDir = async (dir) => {
  await fs.mkdir(dir, { recursive: true });
};

const listImages = async (dir) => {
  const files = await fs.readdir(dir);
  return files.filter((file) => exts.has(path.extname(file).toLowerCase()));
};

const cleanOutput = async (dir) => {
  try {
    const files = await fs.readdir(dir);
    await Promise.all(
      files
        .filter((file) => file.endsWith('.webp') || file.endsWith('.avif'))
        .map((file) => fs.unlink(path.join(dir, file)))
    );
  } catch (error) {
    if (error.code !== 'ENOENT') throw error;
  }
};

const writeManifest = async (manifest) => {
  const contents = `// Auto-generated by scripts/build-gallery.mjs. Do not edit by hand.\n\nexport type GalleryManifestItem = {\n  id: string;\n  width: number;\n  height: number;\n  srcWebp: string;\n  srcAvif: string;\n};\n\nexport const GALLERY_MANIFEST: GalleryManifestItem[] = ${JSON.stringify(
    manifest,
    null,
    2
  )};\n`;

  await ensureDir(manifestDir);
  await fs.writeFile(manifestPath, contents, 'utf8');
};

const main = async () => {
  await ensureDir(inputDir);
  await ensureDir(outputDir);

  const files = await listImages(inputDir);
  if (files.length === 0) {
    console.log('No gallery source images found in public/gallery-src.');
    return;
  }

  await cleanOutput(outputDir);

  const entries = [];

  for (const file of files) {
    const sourcePath = path.join(inputDir, file);
    const id = path.parse(file).name;

    const resized = sharp(sourcePath)
      .rotate()
      .resize({ width: MAX_WIDTH, withoutEnlargement: true });

    const metadata = await resized.metadata();
    if (!metadata.width || !metadata.height) {
      throw new Error(`Failed to read dimensions for ${file}`);
    }

    const webpPath = path.join(outputDir, `${id}.webp`);
    const avifPath = path.join(outputDir, `${id}.avif`);

    await resized.clone().webp({ quality: WEBP_QUALITY }).toFile(webpPath);
    if (ENABLE_AVIF) {
      await resized.clone().avif({ quality: AVIF_QUALITY }).toFile(avifPath);
    }

    entries.push({
      id,
      width: metadata.width,
      height: metadata.height,
      srcWebp: `/gallery/${id}.webp`,
      srcAvif: ENABLE_AVIF ? `/gallery/${id}.avif` : ''
    });

    console.log(`Optimized ${file} -> ${id}.webp${ENABLE_AVIF ? ' + .avif' : ''}`);
  }

  entries.sort((a, b) => a.id.localeCompare(b.id, 'en', { numeric: true }));
  await writeManifest(entries);
  console.log(`Wrote manifest: ${path.relative(cwd, manifestPath)}`);
};

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
